#!/bin/bash -eu
#
# Copyright 2017 The Gardener Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

mod=""
target="$(basename "$(pwd)").tf"
base=-.

defs="variables.tf"
inputs=( )

locals=X

#echo "inputs: $defs"

if [ -z "$header" ]; then
header="##############################################################################
# iaas access configuration handling
# generated by ../create.sh based on local variables.tf
##############################################################################"
fi
if [ -z "$variable" ]; then
  variable="access_info"
fi

contains()
{
  local i
  local e="$1"
  shift
  for i; do
    if [ "$i" == "$e" ]; then
      return 0
    fi
  done
  return 1
}

print_args()
{
  for l in "${inputs[@]}"; do
    echo "  $l = \"\${var.$l}\""
  done
}


print_locals()
{
    cat <<EOF
locals {
  info = "\${merge(var.defaults,var.$variable)}"
EOF
    if [ -n "$locals" ]; then
      echo
      for l in "${simple_inputs[@]}"; do
        cat <<EOF
  $l = "\${var.$l == "" ? lookup(local.info,"$l",var.$l) : var.$l}"
EOF
      done
      echo "}"
    else
      echo "}"
      for l in "${simple_inputs[@]}"; do
        cat <<EOF
module "$l" {
  source="../../variable"
  value="\${var.$l}"
  default="\${lookup(local.info,"$l",var.$l)}"
}
EOF
      done
    fi
}

rvalue()
{
  if [ -n "$locals" ]; then
    echo -n "\"\${local.$1}\""
  else
    echo -n "\"\${module.$1.value}\""
  fi
}

print_simple_args()
{
  print_args "${simple_inputs[@]}"
}

print_args()
{
  for l in "$@"; do
    echo "      $l = $(rvalue $l)"
  done
}

print_outputs()
{
  for l in "${inputs[@]}"; do
    cat <<EOF
output "$l" {
  value = $(rvalue $l)
}
EOF
  done
}

get_variables()
{
  for v in $defs; do
    (
      V=
      T=string
      while read a; do
        n="$(grep "variable[[:space:]]" <<< "$a" | sed -e 's/.*"\(.*\)".*/\1/')"
        if [ -n "$n" ]; then
          if [ -n "$V" ]; then
            echo "$V $T"
          fi
          V="$n"
          T=string
        else
          t="$(grep "type[[:space:]]=" <<< "$a" | sed -e 's/.*"\(.*\)".*/\1/')"
          if [ -n "$t" ]; then
            T="$t"
          fi
        fi
      done
      if [ -n "$V" ]; then
        echo "$V $T"
      fi
    ) < "$v"
  done

}

for v in $defs; do
  while read n t; do
    case "$t" in
      string) simple_inputs+=( $n );;
      list) list_inputs+=( $n );;
      *) echo "invalid variable type '$t' for $n" >&1
         exit 1;;
    esac
  done <<<"$(get_variables)"
done

inputs=( "${simple_inputs[@]}" "${list_inputs[@]}" )

cat >"$target" <<EOF
$header

#
# specify config map to unpack settings into output
#
variable "defaults" {
  type = "map"
  default = {
  }
}
variable "$variable" {
  type = "map"
  default = { }
}

#
# or specify variables according to variables.tf to
# pack a config map
#

$(print_locals)


output "$variable" {
  value = {
$(print_simple_args)
  }
}

#
# always provide all settings as dedicated output
#
$(print_outputs)
EOF
